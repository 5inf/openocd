# SPDX-License-Identifier: GPL-2.0-or-later

#
# target configuration for
# Xilinx ZynqMP (UltraScale+ / A53)
#
if { [info exists CHIPNAME] } {
    set _CHIPNAME $CHIPNAME
} else {
    set _CHIPNAME uscale
}

#
# DAP tap (Quard core A53)
#
if { [info exists DAP_TAPID] } {
    set _DAP_TAPID $DAP_TAPID
} else {
    set _DAP_TAPID 0x5ba00477
}

#https://docs.xilinx.com/r/en-US/ug1085-zynq-ultrascale-trm/Instruction-Register states in the figure the arm tap/dap has irlength 6 ???
jtag newtap $_CHIPNAME tap -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_DAP_TAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.tap

#
# PS tap (UltraScale+)
#
if { [info exists PS_TAPID] } {
    set _PS_TAPID $PS_TAPID
    #This is set to irlen 12, while, according to https://docs.xilinx.com/r/en-US/ug1085-zynq-ultrascale-trm/Instruction-Register, there are actually two taps with length 6
    #However, the second one might not have an idcode register
    jtag newtap $_CHIPNAME ps -irlen 12 -ircapture 0x1 -irmask 0x03 -expected-id $_PS_TAPID
} else {
    # FPGA Programmable logic. Values take from Table 39-1 in UG1085:
    jtag newtap $_CHIPNAME ps -irlen 12 -ircapture 0x1 -irmask 0x03 -ignore-version \
        -expected-id 0x04711093 \
        -expected-id 0x04710093 \
        -expected-id 0x04721093 \
        -expected-id 0x04720093 \
        -expected-id 0x04739093 \
        -expected-id 0x04730093 \
        -expected-id 0x04738093 \
        -expected-id 0x04740093 \
        -expected-id 0x04750093 \
        -expected-id 0x04759093 \
        -expected-id 0x04758093
}

set jtag_configured 0

jtag configure $_CHIPNAME.ps -event setup {
    global _CHIPNAME
    global jtag_configured

    if { $jtag_configured == 0 } {
        # add the DAP tap to the chain
        # See https://forums.xilinx.com/t5/UltraScale-Architecture/JTAG-Chain-Configuration-for-Zynq-UltraScale-MPSoC/td-p/758924
        # See https://docs.xilinx.com/r/en-US/ug1085-zynq-ultrascale-trm/JTAG-Chain-Configuration 0x3 should enable all three tap/dap controllers PS TAP, PL TAP, and Arm DAP
        irscan $_CHIPNAME.ps 0x824
        drscan $_CHIPNAME.ps 32 0x00000003
        runtest 100

        # setup event will be re-entered through jtag arp_init
        # break the recursion
        set jtag_configured 1
        # re-initialized the jtag chain
        jtag arp_init
    }
}

set _TARGETNAME $_CHIPNAME.a53
set _CTINAME $_CHIPNAME.cti
set _smp_command ""


#these addresses are ARM cortex specific, not xilinx specific
#see https://docs.xilinx.com/r/en-US/ug1085-zynq-ultrascale-trm/CoreSight-Address-Map
set A53_DBGBASE {0x80410000 0x80510000 0x80610000 0x80710000}
set A53_CTIBASE {0x80420000 0x80520000 0x80620000 0x80720000}

#Zynq US+ MPSoC Devices ending in CG have two physical A53 cores, EG and EV have four.
#All types have additional two R5 cores, see below
if { [info exists num_a53_cores] } {
	set _num_a53_cores $num_a53_cores
} else {
	set _num_a53_cores 2
}

for { set _core 0 } { $_core < $_num_a53_cores } { incr _core } {

    cti create $_CTINAME.$_core -dap $_CHIPNAME.dap -ap-num 1 -baseaddr [lindex $A53_CTIBASE $_core]

    set _command "target create $_TARGETNAME.$_core aarch64 -dap $_CHIPNAME.dap -dbgbase [lindex $A53_DBGBASE $_core] -cti $_CTINAME.$_core"

    if { $_core != 0 } {
        # non-boot core examination may fail
        set _command "$_command -defer-examine"
        set _smp_command "$_smp_command $_TARGETNAME.$_core"
    } else {
        #-rtos is not really for rtos but for smp support in gdb, see https://openocd.org/doc/html/GDB-and-OpenOCD.html#gdbrtossupport 
        set _command "$_command -rtos hwthread"
        set _smp_command "target smp $_TARGETNAME.$_core"
    }

    eval $_command
}

#see https://docs.xilinx.com/r/en-US/ug1085-zynq-ultrascale-trm/CoreSight-Address-Map
set R5_DBGBASE {0x803F0000 0x803F2000}
set R5_CTIBASE {0x803F8000 0x803F9000}

#The Cortex R5 is an ARMv7-R core. The only ARMv7-R core known to openocd is cortex_r4, however the only main difference is that R5 can have up to two cores, so this might be fine.
#TODO: Testing required, as all of this has not yet been confirmed working.
cti create $_CTINAME.4 -dap $_CHIPNAME.dap -ap-num 1 -baseaddr [lindex $R5_CTIBASE 0]
cti create $_CTINAME.5 -dap $_CHIPNAME.dap -ap-num 1 -baseaddr [lindex $R5_CTIBASE 1]

target create $_CHIPNAME.r5.0 cortex_r4 -dap $_CHIPNAME.dap -dbgbase [lindex $R5_DBGBASE 0]  -defer-examine
# -coreid 0 -cti $_CTINAME.4
target create $_CHIPNAME.r5.1 cortex_r4 -dap $_CHIPNAME.dap -dbgbase [lindex $R5_DBGBASE 1]  -defer-examine 
#-coreid 1 not needed
#-cti $_CTINAME.5 cti is currently only available for aarch64/armv8

target create $_CHIPNAME.axi mem_ap -dap $_CHIPNAME.dap -ap-num 0

# -event post-reset "runtest 100" Move to the run/idle state, and execute at least num cycles of the JTAG clock (TCK). Instructions often need some time to execute before they take effect.



if { [info exists FLASHDRIVER] } {
	set _FLASHDRIVER $FLASHDRIVER
} else {
	set _FLASHDRIVER zynqmp_flash_driver.elf
}

if { [info exists FLASH_MEMORY_BASE] } {
	set _FLASH_MEMORY_BASE $FLASH_MEMORY_BASE
} else {
	echo "FLASH_MEMORY_BASE not given. Will default to 0x70000000"
    #TODO: Add a correct FLASH_MEMORY_BASE as default value. This one is not yet it.
	set _FLASH_MEMORY_BASE 0x70000000 
}

#To support FLASH programming on i.MXRT, download the FLASH plugin from https://github.com/sysprogs/flash_drivers or https://github.com/5inf/openocd_plugin_flash_drivers
#and adjust/uncomment one of the lines below, depending on your processor/flash configuration used:
#The elf file is searched relative to the working directory (=the directory from which openocd is started)
#flash bank imxrt plugin $_FLASH_MEMORY_BASE 0 0 0 0 flashdriver/IMXRT1050_HyperFLASH_ROMAPI.elf
flash bank zynqm plugin 0x8 0 0 0 0 $_FLASHDRIVER